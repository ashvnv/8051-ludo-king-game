;====================================
;	8051 LUDO KING GAME
;	AUTHOR: ASHWIN VALLABAN
;	https://ashvnv.github.io/ashvnv/
;====================================

;====================================================================================
;	MIT License
;
;	Copyright (c) 2024 Ashwin Vallaban (ashvnv)
;
;	Permission is hereby granted, free of charge, to any person obtaining a copy
;	of this software and associated documentation files (the "Software"), to deal
;	in the Software without restriction, including without limitation the rights
;	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;	copies of the Software, and to permit persons to whom the Software is
;	furnished to do so, subject to the following conditions:
;
;	The above copyright notice and this permission notice shall be included in all
;	copies or substantial portions of the Software.
;
;	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;	SOFTWARE.
;====================================================================================

;OVERVIEW OF THE PROJECT
;	LUDO KING GAME ON 8051. THERE WILL BE TWO PLAYERS IN THE GAME, RED AND GREEN. GREEN WILL BE AUTOMATIC AND PLAYER BY
;	8051 ITSELF. THE USER WILL BE THE RED PLAYER. THE ALGORITHM SHOULD DEFINE SOME RULES WHILE PLAYING THE GAME.
;	GAME RULES ARE AS FOLLOWS:
;		INITIALLY THE PLAYER WILL GET A WELCOME MESSAGE ON THE LCD.
;		PLAYER THEN HAS TO PRESS THE 'ROLL' BUTTON ON THE MATRIX KEYPAD.
;		WHEN THE BUTTON IS RELEASED, A RAMDON NUMBER BETWEEN 1 TO 6 WILL BE SHOWN ON THE LCD.
;		INITIALLY THE PLAYER NEEDS TO GET A '6' FOR MAKING THE TOKEN ENTER THE GAME.
;		PLAYER THEN HAS TO SELECT WHICH TOKEN TO MOVE USING THE MATRIX KEYPAD. THE TOKEN WILL THEN BE MOVED
;		TO THE NEW LOCATION. NOW IF THIS NEW LOCATION HAS THE OPPOSITE PLAYER'S TOKEN, THAT TOKEN WILL GO 
;		BACK TO THE HOME LOCATION. THE TOKEN CAN THEN BE REMOVED ONLY IF A '6' IS ROLLED AGAIN.

;OVERVIEW OF THE ALGORITHM
;	RAM LOCATIONS ARE USED AS A VIRTUAL PATH IN THE GAME. 
;	THERE ARE TOTAL 36 RGBs TO BE CONTROLLED FOR EACH PLAYER
;	RAM LOCATION 0x5C TO 0x7F ARE UTILIZED AS THE VIRTUAL PATH IN THE GAME
;	FROM RED PLAYER PERSPECTIVE, LOCATION SHOULD HAVE DATA 0x01
;	FROM GREEN PLAYER PERSPECTIVE, LOCATION SHOULD HAVE DATA 0x02
;	THE ABOVE ALGO MAY SEEM INEFFICIENT AS A BYTE IS USED FOR REPRESENTING RED AND GREEN, IT REDUCES THE 
;	SHIFTING COMPLEXITY IN THE PROJECT. IF 5 REGISTERS ARE USED, TOTAL 40 BITS ARE PRESENT AND CAN
;	SUFFICE THE VIRTUAL PATH REQUIRMENT. BUT WHEN A TOKEN IS BEING SHIFTED, IT NEEDS ADDITIONAL CHECKING IF ANOTHER
;	TOKEN IS PRESENT IN THE SAME BYTE LOCATION WHICH I FEEL WILL COMPLEX EVERYTHING. AND USING THIS TECHNIQUE THERE CAN
;	BE ABOUT 7 PLAYERS (THOUGH GAME CAN BE PLAYED BY 4 PLAYER MAX)PLAYING THE GAME 
;	(1 LESS TO MAKE THE RGB BLACK INDICATING NO TOKEN PRESENT).




; ########## PINS DEFINED BELOW ##########

;***************************************
;PINS USED FOR 16X4 LCD DISPLAY
;***************************************
RS EQU P2.4
EN EQU P2.5
;PORT 1.4 TO 1.7 USED FOR 4 BIT COMMUNICATION WITH 16x4 LCD

;**************************************
;PINS USED FOR 4094
;**************************************
DAT EQU P2.0
CLK_R EQU P2.1; FOR UPDATING RED PLAYER RGBs
CLK_G EQU P2.2; FOR UPDATING GREEN PLAYER RGBs
STR EQU P2.3



; ########## REGISTERS USED #############

;R2 IS USED IN WAIT TIMER INTERRUPT

;R7 USED TO STORE TEMP VALUE IN 4094. ALSO USED TO POLL MATRIX KEY
;0x30 USED AS COUNTER IN 4094 SUBROUTINE. IT IS ALSO USED TO POLL THE PORT 0 MATRIX KEYS
;R0 IS USED AT VARIOUS PLACES FOR INDIRECT ADDRESSING

;0x5C TO 0x7F FOR GAME PATH
;0x31 TO 0x38 FOR TOKEN ADDRESSES

;0x20.0 DIE GAVE 6. A TOKEN CAN BE ADDED TO GAME OR ONE OF THE IN GAME TOKEN CAN BE MOVED BY 6
;0x20.1 IS SET THEN THE NEW TOKEN POSITION WAS VALID
;0x20.2 INDICATES IF THE WAIT IF OVER OR NOT

;0x20.3; IF SET THEN INDICATES NO TOKENS LEFT AT HOME LOCATION

;0x20.4 INDICATES RESET OCCURRED

;0x39 STORES THE DIE VALUE ROLLED
;0x3A HAS THE NEW ADDRESS WHERE TOKEN WILL BE PLACED
;0x3B USED FOR ANL OPERATION WHILE CLEARING TOKEN
;R5 HAS THE LAST MOVED TOKEN



ORG 0H
	LJMP START
	
ORG 001BH
	;TIMER 1 OVERFLOW INTERRUPT
	DJNZ R2, NOT_YET
	SETB 0x20.2; SET THE FLAG
	
	NOT_YET:
	RETI
	
	
; *********** MAIN PROGRAM ************
ORG 100H
	START:
	
	;------ LCD INIT ------
	MOV A, #0x02; 4 BIT MODE
	LCALL LCD_CMD_SEND
	MOV A, #0x28; 5x7 CHAR MODE
	LCALL LCD_CMD_SEND
	MOV A,#0x0C;DISPLAY ON CURSOR OFF
	LCALL LCD_CMD_SEND
	MOV A,#0x06;AUTO INC CURSOR
	LCALL LCD_CMD_SEND
	
	;LCD CURSOR LOCATION
;	#0x80 LINE 1
;	#0xC0 LINE 2
;	#0x90 LINE 3
;	#0xD0 LINE 4

	MOV A, #0xD0;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x4C; L
	LCALL LCD_DATA_SEND
	MOV A, #0x55; U
	LCALL LCD_DATA_SEND
	MOV A, #0x44; D
	LCALL LCD_DATA_SEND
	MOV A, #0x4F; O
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x4B; K
	LCALL LCD_DATA_SEND
	MOV A, #0x49; I
	LCALL LCD_DATA_SEND
	MOV A, #0x4E; N
	LCALL LCD_DATA_SEND
	MOV A, #0x47; G
	LCALL LCD_DATA_SEND


	; --------- INIT DIE TIMER AND WAIT TIMER -------
	;USING TIMER 0 AUTO RELOAD (1 TO 6 VALUE) FOR DIE TIMER
	MOV TMOD, #0x12; TIMER 0 AUTORELOAD MODE AND TIMER 1 16 BIT MODE
	MOV TH0, #0xFA; INIT FROM F9. TL0 WILL OVERFLOW TO FA
	MOV TL0, #0xFA;
	SETB TR0; RUN THIS TIMER FOREVER
	
	
	;---- INTERRUPT FOR TIMER 1 ---
	SETB EA;
	SETB ET1;
	
	
	;SHOW WELCOME ON LCD
	LCALL WC_LCD_MSG
	MOV R2, #18;INIT COUNTER
	LCALL TIMER1_WAIT
	
	;SHOW ROLL
	MOV A, #0x80;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x52; R
	LCALL LCD_DATA_SEND
	MOV A, #0x4F; O
	LCALL LCD_DATA_SEND
	MOV A, #0x4C; L
	LCALL LCD_DATA_SEND
	MOV A, #0x4C; L
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	

	;------ INIT FROM HERE ------
	;RESET ROUTES THE PROGRAM HERE
	RESET_GAME:
	MOV P0, #0x0F; INIT THE MATRIX KEYBOARD

	;INIT ALL THE GAME REGISTERS HERE
	;FIRST CLEAR ALL THE REGISTERS FROM 0x5C TO 0x7F. IMP TO DO THIS AFTER THE GAME IS RESET
	MOV R0, #0x5C
	REPEAT_PATH_CLR:
	MOV @R0, #0x00
	INC R0
	CJNE R0, #0x80, REPEAT_PATH_CLR
	;CLEAR COMPLETE
	
	;FOR TRACKING THE TOKEN LOCATION.
	;FOR RED: TOKEN 1: 0x31
	;		  TOKEN 2: 0x32
	;		  TOKEN 3: 0x33
	;		  TOKEN 4: 0x34	
	;FOR GREEN: TOKEN 1: 0x35
	;		  	TOKEN 2: 0x36
	;		  	TOKEN 3: 0x37
	;		  	TOKEN 4: 0x38
	;RESET ALL THE TOKEN REGISTER TO HOME LOCATION (HOME ADDRESS IS 0x00)
	MOV R0, #0x31
	REPEAT_TOKEN_CLR:
	MOV @R0, #0x00
	INC R0
	CJNE R0, #0x39, REPEAT_TOKEN_CLR
	;CLEAR COMPLETE
	
;	;--------- TEST----------
;;	;FORCE TOKEN ON ANY LINE
;	MOV 0x7C, #0x02
;	MOV 0x35, #0x7C
;;	
;	MOV 0x7D, #0x02
;	MOV 0x36, #0x7D
;;	
;	MOV 0x7A, #0x02
;	MOV 0x37, #0x7A

;	MOV 0x7F, #0x02
;	MOV 0x38, #0x7F

;COMPUTER ALGORITHM TOKEN DOWN CHECK
;	MOV 0x5E, #0x02
;	MOV 0x35, #0x5E

;	MOV 0x5C, #0x02
;	MOV 0x36, #0x5C
;	
;	MOV 0x6C, #0x01
;	MOV 0x31, #0x6C


;;	;------------------------

	;UPDATE THE RGBs
	LCALL UPDATE_RED_RGB
	LCALL UPDATE_GREEN_RGB
	;----- INIT COMPLETE ------
	
	

	
	;----------- START THE GAME FROM HERE ----------
	;LET THE PLAYER ROLL THE DIE FIRST. IF THE PLAYER SCORES A '6' THEN ONE OF THE TOKEN CAN BE TAKEN OUT.
	;NEXT 8051 WILL PLAY. IF IT SCORES '6' THEN IT WILL CHOOSE THE TOKENS IN SEQUENCE AND PLAY
	;TODO 8051 TOKEN LOGIC
	
	;IMPORTANT RULE FUNCTIONS IN THE GAME
	;	0. DIE ROLL AND TOKEN SELECT FUNCTION
	;	1. ADDING THE TOKEN TO THE GAME
	;	2. REMOVING THE TOKEN FROM THE GAME
	;	3. PLACING THE TOKEN
	;		;THIS FUNCTION WILL HAVE ADDITIONAL SUB FUNCTIONS
	;		1. VERIFY WHERE THE TOKEN IS CURRENTLY, AT HOME OR GAME
	;			IF AT HOME THEN CHECK IF DIE ROLL WAS '6', ELSE SKIP THE TOKEN
	;			IF NO OTHER TOKEN IN THE GAME, THEN NEXT PLAYER WILL PLAY
	;		2. VERIFY IF THE TOKEN CAN MOVE TO THE NEW LOCATION. IF ANY OTHER TOKEN PRESENT THEN MOVE THAT TOKEN BACK TO HOME
	;			IF THE TOKEN IS AT PARKING REGISTER 7F, THEN SEE IF THE DIE ROLL IS PROPER TO PARK THE TOKEN
	
	
	; GAME STARTS HERE
	
	;-------------- PLAYER ---------------
	REPEAT_DIE_PLAYER:
	LCALL PLAYER_LCD
	LCALL PLAYER_DIE;
	
	;CHECK IF RESET CLICKED
	JNB 0x20.4, NOT_RESET
	;RESET CLICKED. GO TO RESET ROUTINE
	LJMP FORCE_RESET
	
	NOT_RESET:
	;IF 0x39 HAS 6, THEN SET 0x20.0. IN TOKEN SELECT, IF TOKEN IN HOME IT CAN BE ADDED TO THE GAME
	MOV A, 0x39
	CJNE A, #0x06, NOT_PREV_PLAYER
	SETB 0x20.0; 6 WAS SCORED
	
	NOT_PREV_PLAYER:
	;HERE WE ALSO NEED TO CHECK IF THE PLAYER HAS ANY VALID MOVES.
	;IF 6 WAS SCORED THEN SKIP THIS CHECK.
	;VALIDITY CHECK IF AS FOLLOWS:
	;	FIRST CHECK IF ANY TOKEN IS IN THE GAME, IF NOT THEN INVALID
	;	CHECK IF THE TOKENS ARE MOVED DIE VALUE POSITIONS, IS IT WITHIN THE VIRTUAL PATH BOUND (7F)
	;---------------- VALIDITY STARTS HERE --------------------
	MOV R0, #0x30
	MOV R6, #0x01; PLAYER TOKEN MASK
	
	LCALL VALIDITY_CHECK
	;IF 0x20.3 IS SET THEN VALID. ELSE INVALID
	JB 0x20.3, REPEAT_TOKEN_SELECT_PLAYER; VALID GO TO NEXT STEP
	LJMP PLAYER_MOVES_DONE; INVALID
	
;	VALIDITY_CHECK1_CONT:
;	CJNE R0, #0x34, CONT_VALIDITY_CHECK1
;	;NO VALID MOVES LEFT WITH PLAYER. LET COMPUTER PLAY
;	
;	LCALL INVALID_LCD_MSG
;	MOV R2, #18;INIT COUNTER
;	LCALL TIMER1_WAIT
;	
;	LJMP PLAYER_MOVES_DONE
;	
;	CONT_VALIDITY_CHECK1:
;	INC R0
;	MOV A, @R0
;	JNZ FOUND_TOKEN_OUTSIDE_HOME
;	
;	;INDICATES 6 WAS SCORED, A TOKEN IS AVAILABLE AT THE HOME POSITION
;	JB 0x20.0, REPEAT_TOKEN_SELECT_PLAYER; SKIP THIS STEP IF '6' WAS SCORED
;	SJMP VALIDITY_CHECK1_CONT
;	
;	FOUND_TOKEN_OUTSIDE_HOME:
;	;VALID TOKEN POSITION FOUND. NOW CHECK IF TOKENS HAVE VALID END ADDRESS
;	ADD A, 0x39; ADD CURRENT DIE VAL TO VALID TOKEN
;	CLR C; CLEAR CARRY
;	SUBB A, #0x80
;	;IF CARRY GENERATED, THEN INVALID MOVE
;	JNC VALIDITY_CHECK1_CONT; GO BACK
;	;CARRY SO VALID TOKEN FOUND
;	
;	;CHECK IF THAT LOCATION HAS SAME PLAYER TOKEN
;	MOV A, @R0
;	ADD A, 0x39
;	MOV R1, A
;	MOV A, @R1
;	ANL A, #0x01
;	CJNE A, #0x01, REPEAT_TOKEN_SELECT_PLAYER; IF END ADDRESS DOES NOT HAVE THE RED PATTERN THIS IT IS VALID
;	SJMP VALIDITY_CHECK1_CONT; REPEAT CHECK
	;-----------------------------------------------------------

	
	;HERE CHECK WHICH TOKEN IS SELECTED.
	REPEAT_TOKEN_SELECT_PLAYER:
	LCALL TOKEN_SELECT
	;R0 HAS THE TOKEN ADDRESS WHICH WAS SELECTED
	
	;NOW CHECK IF THE TOKEN IS AT HOME OR IN THE GAME.
	MOV A, @R0
	JNZ NOT_AT_HOME_PLAYER
	;PLAYER AT HOME
	;VERIFY IF 0x20.0 FLAG IS SET. IF YES THEN ADD THE TOKEN TO THE GAME. ELSE GO BACK TO TOKEN_SELECT
	;JNB 0x20.0, REPEAT_TOKEN_SELECT_PLAYER; NOT SCORED '6' SO CANNOT ADD TO THE GAME
	JB 0x20.0, ADD_TOKEN_TO_PATH_TRUE
	
	;SHOW MOVE NA MESSGAE ON LCD
	LCALL NA_LCD_MSG
	MOV R2, #18;INIT COUNTER
	LCALL TIMER1_WAIT
	;GO BACK AND REPEAT AGAIN
	LJMP REPEAT_TOKEN_SELECT_PLAYER
	
	
	ADD_TOKEN_TO_PATH_TRUE:
	;CALL THE TOKEN PLACE SUBROUTINE. IT UNDERGOES SOME CONDITIONS AND TELLS IF THE TOKEN CAN BE ADDED TO NEW POSITION OR NOT
	;R0 HAS THE TOKEN ADDRESS AND 0x3A WILL HAVE THE NEW TOKEN ADDRESS
	MOV 0x3A, #0x5C; INIT START LOCATION FOR PLAYER
	
	LCALL TOKEN_PLACE_PLAYER
	JNB 0x20.1, REPEAT_TOKEN_SELECT_PLAYER;
	;UPDATE THE TOKEN ADDRESS AND ADD THE TOKEN TO NEW LOCATION
	MOV A, 0x5C
	ORL A, #0x01; ADD PLAYER TOKEN
	MOV 0x5C, A
	MOV @R0, #0x5C; NEW ADDRESS OF THE TOKEN SELECTED
	
	LJMP PLAYER_MOVES_DONE
	
	
	NOT_AT_HOME_PLAYER:
	;PLAYER IS NOT AT HOME
	;HERE CHECK IF THE TOKEN CAN BE MOVED TO THE NEW LOCATION.
	;0x39 HAS THE DIE VALUE
	;0x3A HAS THE NEW TOKEN ADDRESS
	MOV A, @R0
	ADD A, 0x39; ADD NEW DIE VALUE
	MOV 0x3A, A; NEW ADDRESS STORED IN 0x3A
	
	LCALL TOKEN_PLACE_PLAYER
	JNB 0x20.1, REPEAT_TOKEN_SELECT_PLAYER;
	;CLEAR THE CURRENT LOCATION TOKEN
	MOV A, @R0
	MOV R1, A
	MOV 0x3B, @R1
	ANL 0x3B, #0xFE; REMOVE THE PLAYER TOKEN (0x01)
	MOV @R1, 0x3B
	
	;UPDATE THE TOKEN ADDRESS AND ADD THE TOKEN TO NEW LOCATION
	MOV @R0, 0x3A
	MOV R1, 0x3A
	MOV 0x3B, @R1
	ORL 0x3B, #0x01
	MOV @R1, 0x3B; ADD TOKEN TO NEW LOCATION
	LJMP PLAYER_MOVES_DONE
		
		
	PLAYER_MOVES_DONE:
	LCALL UPDATE_RED_RGB
	LCALL UPDATE_GREEN_RGB
	;CHECK HERE IS 0x20.0 WAS SET. IF YES THEN REPEAT PLAYER'S CHANCE.
	
;	;TEST
;	CLR 0x20.0;LET COMPUTER PLAY NEXT
	
	;----- CHECK IF PLAYER WON ------
	LCALL CHECK_PLAYER_WON
	CJNE A, #0x04, PLAYER_NOT_WON
	;PLAYER WON. SHOW WON ON THE DISPLAY AND STOP STILL RESET
	LCALL CLEAR_LCD_MSG
	LCALL WON_LCD_MSG
	LJMP WAIT_FOR_RESET; GAME OVER. WAIT FOR RESET
	
	
	PLAYER_NOT_WON:
	
	
	JNB 0x20.0, COMPUTER_PLAY_NEXT
	CLR 0x20.0; CLEAR THE FLAG
	LJMP REPEAT_DIE_PLAYER
	
	
	COMPUTER_PLAY_NEXT:
	;HERE 8051 WILL MAKE THE MOVE
	;NOW THIS STEP IS TRICKY. COMPUTER ALGORITHM WILL WORK AS FOLLOWS:
	;	FIRST LET IT ROLL THE DIE AFTER SOME DELAY
	;	NOW SEE IF THE ROLLED DIE VALUE GIVES A VALID MOVE.
	;	IF YES THEN CHECK WHICH TOKEN CAN BE MOVED. IF A 6 WAS SCORED TAKE THE TOKEN OUT.
	;	IF ONE OF THE PLAYER TOKEN CAN BE MOVED BACK HOME, DO IT INSTEAD.
	;	SO THE SUMMARY OF THE ALGORITHM IS AS FOLLOWS:
	;		1. ROLL THE DIE
	;		2. IF 6 THEN PREVILIGED, NOW SEE IF ANO TOKEN OUT IN THE GAME. IF YES THEN SEE IF THE ROLL
	;				CAN MAKE A PLAYER TOKEN GO BACK HOME. IF YES THEN DO IT. IF ANY NO PREVIOUSLY THEN
	;				TAKE A TOKEN OUT AND REPEAT.
	;		   IF OTHER THAN 6 SCORED THEN CHECK IF ANY ROLL CAN MAKE THE PLAYER GO BACK HOME.
	;		       IF YES THEN MOVE THAT TOKEN
	;		   IF NO THEN SIMPLE MOVE THE TOKEN WHICH WAS NOT MOVED BEFORE. BETTER TO HAVE A REGISTER
	;			 STATING WHICH TOKEN WAS MOVED LAST
	
	LCALL COMPUTER_LCD
	
	;FIRST ROLL THE DIE
	LCALL COMPUTER_DIE
	;IF 0x39 HAS 6, THEN SET 0x20.0. IN TOKEN SELECT, IF TOKEN IN HOME IT CAN BE ADDED TO THE GAME
	MOV A, 0x39
	CJNE A, #0x06, NOT_PREV_COMPUTER
	SETB 0x20.0; 6 WAS SCORED
	
	NOT_PREV_COMPUTER:
	
	;---------------- VALIDITY STARTS HERE --------------------
	MOV R0, #0x34; COMPUTER TOKEN ADD - 1
	MOV R6, #0x02; COMPUTER TOKEN MASK
	
	LCALL VALIDITY_CHECK
	;IF 0x20.3 IS SET THEN VALID. ELSE INVALID
	JB 0x20.3, TOKEN_SELECT_COMPUTER; VALID GO TO NEXT STEP
	LJMP COMPUTER_MOVES_DONE; INVALID
	
	
	TOKEN_SELECT_COMPUTER:
	
;	;FOR TESTING
;	WAIT_FOR_MATRIX: JB P0.0, WAIT_FOR_MATRIX
	
	
	;NOW SEE WHICH TOKEN TO MOVE. THE TRICKY PART STARTS FROM HERE
	;INIT THE TOKEN CHECKER HERE
	;SEE IF THE TOKEN IS IN THE GAME OR NOT
	;0x39 HAS THE DIE ROLL VALUE
	MOV R1, #0x34;INIT THE TOKEN COUNTER
	
	TOKEN_COUNTER_NXT:
	CJNE R1, #0x38, KEEP_CHECKING_TOKEN_COMP
	;NO TOKEN WHICH CAN REMOVE PLAYER TOKEN FOUND IN THE GAME
	
	;=====================================================================
	;NOW CHECK IF '6' WAS SCORED. IF YES THEN ADD A NEW TOKEN
	JB 0x20.0, ADD_A_COMP_TOKEN
	LJMP TOKEN_MOVE_COMP;MOVE AN EXISTING TOKEN IN THE GAME
	
	ADD_A_COMP_TOKEN:
	;HERE WE WRITE A LOGIC FOR ADDING A TOKEN TO THE GAME.
	;IF NO TOKEN AVAILABLE AT HOME THEN JUMP TO TOKEN_MOVE_COMP
	MOV R1, #0x34
	
	CHECK_NEXT_COMP_TOKEN_ADDING:
	CJNE R1, #0x38, CHECK_COMP_TOKEN_AT_HOME
	LJMP TOKEN_MOVE_COMP; NO TOKEN AT HOME. MOVE THE EXISTING TOKEN. GOES TO TOKEN_MOVE_COMP
	
	CHECK_COMP_TOKEN_AT_HOME:
	INC R1
	MOV A, @R1
	JNZ CHECK_NEXT_COMP_TOKEN_ADDING
	
	;A TOKEN FOUND AT HOME LOCATION
	;R1 HAS THE TOKEN ADDRESS
	;CHECK IF COMP TOKEN IS AT 0x5C LOCATION. IF YES THEN SKIP THIS STEP AND MOVE THE TOKEN AT 0x5C
	MOV A, 0x5C
	ANL A, #0x02
	CJNE A, #0x02, COMP_TOKEN_NOT_AT_START
	LJMP TOKEN_MOVE_COMP; MOVE TOKEN INSTEAD
	
	
	COMP_TOKEN_NOT_AT_START:
	;CHECK IF PLAYER TOKEN PRESENT AT 0x5C. IF YES THEN REMOVE IT AND ADD COMP TOKEN
	MOV R0, #0x6C; PLAYER MERGE PATH
	MOV A, @R0
	ANL A, #0x01;PLAYER MASK
	CJNE A, #0x01, ADD_WITHOUT_REMOVE_PLAYER
	;PLAYER TOKEN FOUND REMOVE IT
	MOV R0, #0x30;INIT PLAYER TOKEN FINDER

	NOT_FOUND_PLAYER_TO_RM:
	INC R0
	MOV A, @R0
	CJNE A, #0x6C, NOT_FOUND_PLAYER_TO_RM
	;FOUND THE PLAYER TOKEN. STORED IN R0
	
	MOV @R0, #0x00; RESET PLAYER TOKEN
	MOV 0x3B, 0x6C
	ANL 0x3B, #0xFE; REMOVE THE PLAYER TOKEN
	MOV 0x6C, 0x3B; CLEAR TOKEN RAM FOR PLAYER
	
	ADD_WITHOUT_REMOVE_PLAYER:
	MOV @R1, #0x5C
	MOV A, 0x5C
	ORL A, #0x02; ADD COMPUTER TOKEN
	MOV 0x5C, A
	;DONE ADDING
	
	LJMP COMPUTER_MOVES_DONE
	;=========================================================================
	
	
	KEEP_CHECKING_TOKEN_COMP:
	INC R1
	MOV A, @R1; GET THE TOKEN ADDRESS
	JZ TOKEN_COUNTER_NXT
	;FOUND A TOKEN IN THE GAME
	ADD A, 0x39; NEW ADDRESS OF THE TOKEN
	
	;VERIFY IF THE TOKEN ADDRESS IS LESS THAN 0x7F
	CLR C; CLEAR CARRY
	SUBB A, #0x80
	;IF CARRY GENERATED, THEN VALID MOVE
	JNC TOKEN_COUNTER_NXT; INVALID MOVE. CHECK NEXT
	
	;CHECK IF THE END LOCATION IS BELOW 0xFC. THIS IS BECAUSE LOCATION FROM 0x7C TO 0x7F, PLAYER CANNOT ENTER
	MOV A, @R1
	ADD A, 0x39
	CLR C
	SUBB A, #0x7C
	;IF CARRY GENERATED THEN INVALID. ELSE INVALID
	JNC TOKEN_COUNTER_NXT;
	
	;CARRY GENERATED. NOW CHECK IF IT CAN REMOVE PLAYER TOKEN
	
	;========= CHECK IF IT CAN TAKE DOWN PLAYER TOKEN ========
	;CHECK IF NEW LOCATION HAS PLAYER TOKEN.
	MOV 0x07, R1; BACKUP R7
	
	MOV A, @R1
	ADD A, 0x39
	MOV R1, A; NEW ADDRESS OF THE COMPUTER TOKEN
	
	MOV A, R1; CALCULATE THE OFFSET LOCATION FIRST
	CLR C; CLEAR CARRY
	SUBB A, #0x6C
	;IF CARRY GENERATED, THEN INC BY 0x10
	JC PLAY_TOKEN_INC_F
	;PLAYER TOKEN DEC BY F
	MOV A, R1
	CLR C
	SUBB A, #0x10
	MOV R1, A
	SJMP COMP_TOKEN_GET_STEP_DONE
	
	PLAY_TOKEN_INC_F:
	MOV A, R1
	ADD A, #0x10
	MOV R1, A
	
	COMP_TOKEN_GET_STEP_DONE:
	MOV A, @R1; GET PLAYER MERGE PATH
	
	ANL A, #0x01; MASK
	CJNE A, #0x01, NO_PLAYER_TOKEN
	;PLAYER TOKEN FOUND AND STORED IN R1
	;NOW REMOVE THE PLAYER TOKEN AND GO TO COMPUTER_MOVES_DONE
	MOV R0, #0x30
	
	CHECK_NEXT_PLAY_TOKEN:
	INC R0
	MOV A, @R0
	CJNE A, 0x01, CHECK_NEXT_PLAY_TOKEN
	;FOUND TOKEN. STORED IN R0
	MOV @R0, #0x00; RESET TOKEN ADDRESS
	MOV 0x3B, @R1
	ANL 0x3B, #0xFE; REMOVE THE PLAYER TOKEN
	MOV @R1, 0x3B
	
	;UPDATE COMPUTER TOKEN
	;R7 HAS THE TOKEN ADDRESS OF COMPUTER WHICH REMOVED PLAYER TOKEN
	;FIRST CLEAR THE COMPUTER TOKEN FROM INITIAL LOCATION
	MOV R1, 0x07
	
	MOV 0x00, @R1; INIT A NEW POINTER
	MOV A, @R0
	ANL A, #0xFD; CLEAR CURRENT COMPUTER LOCATION REGISTER
	MOV @R0, A
	
	MOV A, @R1
	ADD A, 0x39; ADD DIE VALUE
	MOV @R1, A; UPDATE COMPUTER TOKEN
	
	MOV 0x00, @R1
	MOV A, @R0
	ORL A, #0x02; ADD COMPUTER TOKEN
	MOV @R0, A
	
	LJMP COMPUTER_MOVES_DONE
	
	
	NO_PLAYER_TOKEN:
	;NO PLAYER TOKEN FOUND. SO SKIP AND GO TO NEXT TOKEN
	MOV R1, 0x07;; RESTORE R1
	LJMP TOKEN_COUNTER_NXT
	
	
	TOKEN_MOVE_COMP:
	;HERE AN EXISTING TOKEN IS MOVED.
	;NOW CHECK WHICH TOKEN TO MOVE. R5 STORES THE LAST MOVED TOKEN. IT IS BETWEEN 0 TO 3
	
	CJNE R5, #0x00, CHECK_NEXT_COMP_MOVE
	;0x35 TOKEN WAS MOVED
	;MOVE 0x36
	MOV R5, #0x01; OVERWRITE

;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	MOV A, 0x36
	JZ CHECK_NEXT_COMP_MOVE; CANNOT MOVE 0x36, TOKEN AT HOME
	
	MOV R0, #0x36
	MOV A, @R0
	ADD A, 0x39; ADD DIE VALUE
	CLR C
	SUBB A, #0x80
	
	JNC CHECK_NEXT_COMP_MOVE; GOING BEYOND THE BOUND
	;CARRY. VALID. MOVE 0x36 TOKEN

	;CHECK IF THE END ADDRESS HAS COMPUTER PATTERN OR NOT
	MOV R1, #0x36
	MOV A, @R1
	ADD A, 0x39
	MOV R1, A
	MOV A, @R1
	ANL A, #0x02
	CJNE A, #0x02, NO_COMP_PATTERN_FOUND
	;COMP PATTERN FOUND. SKIP THIS STEP
	SJMP CHECK_NEXT_COMP_MOVE

	NO_COMP_PATTERN_FOUND:
	;CLEAR CURRENT LOCATION
	MOV 0x01, @R0
	;CHANGED TOKEN POSITION
	MOV A, @R0
	ADD A, 0x39
	MOV @R0, A
	MOV 0x3B, @R1
	ANL 0x3B, #0xFD; REMOVE THE COMPUTER TOKEN
	MOV @R1, 0x3B
	
	MOV 0x01, @R0
	MOV A, @R1
	ORL A, #0x02; ADD COMPUTER
	MOV @R1, A
	LJMP COMPUTER_MOVES_DONE
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	
	
	CHECK_NEXT_COMP_MOVE:
	CJNE R5, #0x01,CHECK_NEXT_COMP_MOVE1
	;0x36 TOKEN WAS MOVED
	;MOVE 0x37
	MOV R5, #0x02; OVERWRITE
	
	
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	MOV A, 0x37
	JZ CHECK_NEXT_COMP_MOVE1; CANNOT MOVE 0x36, TOKEN AT HOME
	
	MOV R0, #0x37
	MOV A, @R0
	ADD A, 0x39; ADD DIE VALUE
	CLR C
	SUBB A, #0x80
	
	JNC CHECK_NEXT_COMP_MOVE1; GOING BEYOND THE BOUND
	;CARRY. VALID. MOVE 0x36 TOKEN

	;CHECK IF THE END ADDRESS HAS COMPUTER PATTERN OR NOT
	MOV R1, #0x37
	MOV A, @R1
	ADD A, 0x39
	MOV R1, A
	MOV A, @R1
	ANL A, #0x02
	CJNE A, #0x02, NO_COMP_PATTERN_FOUND1
	;COMP PATTERN FOUND. SKIP THIS STEP
	SJMP CHECK_NEXT_COMP_MOVE1

	NO_COMP_PATTERN_FOUND1:
	;CLEAR CURRENT LOCATION
	MOV 0x01, @R0
	;CHANGED TOKEN POSITION
	MOV A, @R0
	ADD A, 0x39
	MOV @R0, A
	MOV 0x3B, @R1
	ANL 0x3B, #0xFD; REMOVE THE COMPUTER TOKEN
	MOV @R1, 0x3B
	
	MOV 0x01, @R0
	MOV A, @R1
	ORL A, #0x02; ADD COMPUTER
	MOV @R1, A
	LJMP COMPUTER_MOVES_DONE
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	
	
	
	CHECK_NEXT_COMP_MOVE1:
	CJNE R5, #0x02,CHECK_NEXT_COMP_MOVE2
	;0x37 TOKEN WAS MOVED
	;MOVE 0x38
	MOV R5, #0x03; OVERWRITE
	
	
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	MOV A, 0x38
	JZ CHECK_NEXT_COMP_MOVE2; CANNOT MOVE 0x36, TOKEN AT HOME
	
	MOV R0, #0x38
	MOV A, @R0
	ADD A, 0x39; ADD DIE VALUE
	CLR C
	SUBB A, #0x80
	
	JNC CHECK_NEXT_COMP_MOVE2; GOING BEYOND THE BOUND
	;CARRY. VALID. MOVE 0x36 TOKEN

	;CHECK IF THE END ADDRESS HAS COMPUTER PATTERN OR NOT
	MOV R1, #0x38
	MOV A, @R1
	ADD A, 0x39
	MOV R1, A
	MOV A, @R1
	ANL A, #0x02
	CJNE A, #0x02, NO_COMP_PATTERN_FOUND2
	;COMP PATTERN FOUND. SKIP THIS STEP
	SJMP CHECK_NEXT_COMP_MOVE2

	NO_COMP_PATTERN_FOUND2:
	;CLEAR CURRENT LOCATION
	MOV 0x01, @R0
	;CHANGED TOKEN POSITION
	MOV A, @R0
	ADD A, 0x39
	MOV @R0, A
	MOV 0x3B, @R1
	ANL 0x3B, #0xFD; REMOVE THE COMPUTER TOKEN
	MOV @R1, 0x3B
	
	MOV 0x01, @R0
	MOV A, @R1
	ORL A, #0x02; ADD COMPUTER
	MOV @R1, A
	LJMP COMPUTER_MOVES_DONE
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	
	
	CHECK_NEXT_COMP_MOVE2:
	;0x38 TOKEN WAS MOVED
	;MOVE 0x35
	MOV R5, #0x00; OVERWRITE	

;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
	MOV A, 0x35
	JZ CHECK_NEXT_COMP_MOVE3; CANNOT MOVE 0x36, TOKEN AT HOME
	
	MOV R0, #0x35
	MOV A, @R0
	ADD A, 0x39; ADD DIE VALUE
	CLR C
	SUBB A, #0x80
	
	JNC CHECK_NEXT_COMP_MOVE3; GOING BEYOND THE BOUND
	;CARRY. VALID. MOVE 0x36 TOKEN

	;CHECK IF THE END ADDRESS HAS COMPUTER PATTERN OR NOT
	MOV R1, #0x35
	MOV A, @R1
	ADD A, 0x39
	MOV R1, A
	MOV A, @R1
	ANL A, #0x02
	CJNE A, #0x02, NO_COMP_PATTERN_FOUND3
	;COMP PATTERN FOUND. SKIP THIS STEP
	SJMP CHECK_NEXT_COMP_MOVE3

	NO_COMP_PATTERN_FOUND3:
	;CLEAR CURRENT LOCATION
	MOV 0x01, @R0
	;CHANGED TOKEN POSITION
	MOV A, @R0
	ADD A, 0x39
	MOV @R0, A
	MOV 0x3B, @R1
	ANL 0x3B, #0xFD; REMOVE THE COMPUTER TOKEN
	MOV @R1, 0x3B
	
	MOV 0x01, @R0
	MOV A, @R1
	ORL A, #0x02; ADD COMPUTER
	MOV @R1, A
	LJMP COMPUTER_MOVES_DONE
;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


	CHECK_NEXT_COMP_MOVE3:
	LJMP TOKEN_MOVE_COMP
	
	COMPUTER_MOVES_DONE:
	;SHOW THINKING MESSAGE FOR SOMETIME
	;ALSO IMPORTANT FOR PLAYER TO KNOW DIE ROLLED VALUE
	
	;IF 0x20.3 IS SET THEN VALID. ELSE INVALID
	JNB 0x20.3, SKIP_LCD_THINK_MSG	
	LCALL THINK_LCD_MSG
	MOV R2, #20;INIT COUNTER
	LCALL TIMER1_WAIT
	LCALL CLEAR_LCD_MSG
	
	SKIP_LCD_THINK_MSG:
	LCALL UPDATE_RED_RGB
	LCALL UPDATE_GREEN_RGB
	;CHECK HERE IS 0x20.0 WAS SET. IF YES THEN REPEAT COMPUTER'S CHANCE.
	
;	;TEST
;	CLR 0x20.0;LET PLAYER PLAY NEXT
	
	;----- CHECK IF COMPUTER WON ------
	LCALL CHECK_COMPUTER_WON
	CJNE A, #0x08, COMPUTER_NOT_WON
	;COMPUTER WON. SHOW ALL DISPLAY AND STOP STILL RESET
	LCALL CLEAR_LCD_MSG
	LCALL WON_LCD_MSG
	
	LJMP WAIT_FOR_RESET; GAME OVER. WAIT FOR RESET
	
	
	COMPUTER_NOT_WON:
	JNB 0x20.0, PLAYER_PLAY_NEXT
	CLR 0x20.0; CLEAR THE FLAG
	LJMP COMPUTER_PLAY_NEXT; REPEAT AGAIN
	
	PLAYER_PLAY_NEXT:
	LJMP REPEAT_DIE_PLAYER

	
	WAIT_FOR_RESET:
	JB P0.0, WAIT_FOR_RESET
	
	;PROGRAM JUMPED HERE WHEN RESET BUTTON IS CLICKED IN-BETWEEN THE GAME
	FORCE_RESET:
	;SHOW RESET ON LCD
	LCALL RESET_LCD_MSG
	MOV R2, #20;INIT COUNTER
	LCALL TIMER1_WAIT
	LCALL CLEAR_LCD_MSG
	
	;RESET OCCURRED. GO BACK
	LJMP RESET_GAME


ORG 450H
	CHECK_PLAYER_WON:
	;CHECK IF THE PLAYER WON THE GAME
	;COUNT FROM 0x7C TO 0x7F
	;IF IT IS EQUAL TO 4 THEN PLAYER WON. VALUE STORED IN A
	
	MOV R0, #0x7B
	MOV A, #0x00; CLEAR
	
	NOT_YET_WON_COUNTED_PLAYER:
	INC R0
	MOV 0x07, @R0
	ANL 0x07, #0x01; COUNT PLAYER
	ADD A, R7
	CJNE R0, #0x7F, NOT_YET_WON_COUNTED_PLAYER
	;COUNTED
	RET
	

ORG 470H
	CHECK_COMPUTER_WON:
	;CHECK IF THE COMPUTER WON THE GAME
	;COUNT FROM 0x7C TO 0x7F
	;IF IT IS EQUAL TO 8 THEN COMPUTER WON. VALUE STORED IN A
	
	MOV R0, #0x7B
	MOV A, #0x00; CLEAR
	
	NOT_YET_WON_COUNTED_COMP:
	INC R0
	MOV 0x07, @R0
	ANL 0x07, #0x02; COUNT COMPUTER
	ADD A, R7
	CJNE R0, #0x7F, NOT_YET_WON_COUNTED_COMP
	;COUNTED
	RET


ORG 48AH
	;SHOW WON ON LCD
	WON_LCD_MSG:
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x57; W
	LCALL LCD_DATA_SEND
	MOV A, #0x4F; O
	LCALL LCD_DATA_SEND
	MOV A, #0x4E; N
	LCALL LCD_DATA_SEND
	RET
	
	RESET_LCD_MSG:
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x52; R
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x53; S
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x54; T
	LCALL LCD_DATA_SEND
	RET

ORG 4F0H
	TIMER1_WAIT:
	CLR 0x20.2
	SETB TR1
	WAIT_FOR_TIMER1: JNB 0x20.2, WAIT_FOR_TIMER1
	CLR TR1
	LCALL CLEAR_LCD_MSG
	RET
	
ORG 510H
	THINK_LCD_MSG:
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x49; I
	LCALL LCD_DATA_SEND
	MOV A, #0x4E; N
	LCALL LCD_DATA_SEND
	MOV A, #0x53; S
	LCALL LCD_DATA_SEND
	MOV A, #0x50; P
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x43; C
	LCALL LCD_DATA_SEND
	MOV A, #0x54; T
	LCALL LCD_DATA_SEND
	
	RET
	

ORG 540H
	CLEAR_LCD_MSG:
	;FOR CLEARING THE 0x90 LINE OF LCD
	
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	
	RET

ORG 570H
	WC_LCD_MSG:
	
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x57; W
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x4C; L
	LCALL LCD_DATA_SEND
	MOV A, #0x43; C
	LCALL LCD_DATA_SEND
	MOV A, #0x4F; O
	LCALL LCD_DATA_SEND
	MOV A, #0x4D; M
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	
	RET

ORG 5A0H
	INVALID_LCD_MSG:
	
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x49; I
	LCALL LCD_DATA_SEND
	MOV A, #0x4E; N
	LCALL LCD_DATA_SEND
	MOV A, #0x56; V
	LCALL LCD_DATA_SEND
	MOV A, #0x41; A
	LCALL LCD_DATA_SEND
	MOV A, #0x4C; L
	LCALL LCD_DATA_SEND
	MOV A, #0x49; I
	LCALL LCD_DATA_SEND
	MOV A, #0x44; D
	LCALL LCD_DATA_SEND
	
	RET

ORG 5D0H
	NA_LCD_MSG:
	;FOR CLEARING THE 0x90 LINE OF LCD
	
	MOV A, #0x90;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x4D; M
	LCALL LCD_DATA_SEND
	MOV A, #0x4F; O
	LCALL LCD_DATA_SEND
	MOV A, #0x56; V
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x4E; N
	LCALL LCD_DATA_SEND
	MOV A, #0x41; A
	LCALL LCD_DATA_SEND
	
	RET


;@@@@@@@@@@@@ SUBROUTINE FOR PLAYER @@@@@@@@@@@@@@
ORG 600H
	;--------------- SELECT THE TOKEN ----------------
	TOKEN_SELECT:
	MOV 0x30, P0;
	
	;WAIT TILL KEY IS CLICKED ON THE MATRIX
	WAIT_FOR_STATE_CHANGE:
	JNB P0.0, RESET_TOKEN
	JNB P0.1, KEY4
	JNB P0.2, STATE_CHANGED
	SJMP WAIT_FOR_STATE_CHANGE
	
	RESET_TOKEN:
	;RESET WAS CLICKED. DO SOMETHING
	LJMP FORCE_RESET
	RET

	STATE_CHANGED:
	SETB P0.4
	JB P0.2, KEY1
	
	SETB P0.5
	JB P0.2, KEY2
	
	SETB P0.6
	JB P0.2, KEY3
	
	
	;TOKEN ADDRESS DEFINED BELOW FOR PLAYER
	
	KEY1:
	MOV R0, #0x31
	SJMP TOKEN_SELECT_OVER
	
	KEY2:
	MOV R0, #0x32
	SJMP TOKEN_SELECT_OVER
	
	KEY3:
	MOV R0, #0x33
	SJMP TOKEN_SELECT_OVER
	
	KEY4:
	MOV R0, #0x34
	
	TOKEN_SELECT_OVER:
	MOV P0, #0x0F
	WAIT_FOR_KEY_RELEASE:
	MOV P0, #0x0F
	JNB P0.1, WAIT_FOR_KEY_RELEASE
	JNB P0.2, WAIT_FOR_KEY_RELEASE
	
	RET


	
	TOKEN_PLACE_PLAYER:
	;R0 HAS THE TOKEN ADDRESS. 0x3A HAS THE NEW TOKEN ADDRESS. R7 IS USED FOR BACKUP
	MOV R1, 0x3A
	;VERIFY IF THE NEW LOCATION IS WITHIN 7F BOUND
	MOV A, R1;
	CLR C; CLEAR CARRY
	SUBB A, #0x80
	;IF CARRY GENERATED, THEN VALID MOVE
	JC VALID_NEW_LOCATION_PLAYER0;
	SJMP INVALID_PLAYER_LOCATION
	
	VALID_NEW_LOCATION_PLAYER0:
	;NOW VERIFY IS THE NEW LOCATION HAS PLAYER TOKEN
	MOV A, @R1
	ANL A, #0x01; MASK OTHER BITS
	CJNE A, #0x01, VALID_NEW_LOCATION_PLAYER; IF NOT MATCHING THEN VALID.
	SJMP INVALID_PLAYER_LOCATION
	
	VALID_NEW_LOCATION_PLAYER:
	
	;NOW CHECK IF THE OTHER PLAYER'S TOKEN PRESENT OR NOT
	;PLAYER PATH AND COMPUTER PATH MERGE FROM LOCATION 0x5C
	;PLAYER PATH. FROM 0x5C TO 0x6B, COMPUTER PATH IS INC BY 0x10
	;			  FROM 0x6C TO 0x7B, COMPUTER PATH IS DEC BY 0x10
	
	;CHECK IF NEW LOCATION HAS COMPUTER TOKEN
	MOV A, R1; CALCULATE THE OFFSET LOCATION FIRST
	CLR C; CLEAR CARRY
	SUBB A, #0x6C
	;IF CARRY GENERATED, THEN INC BY 0x10
	JC COMP_TOKEN_INC_F
	;COMPUTER TOKEN DEC BY F
	MOV A, R1
	CLR C
	SUBB A, #0x10
	MOV R1, A
	SJMP TOKEN_GET_STEP_DONE
	
	COMP_TOKEN_INC_F:
	MOV A, R1
	ADD A, #0x10
	MOV R1, A
	
	TOKEN_GET_STEP_DONE:
	MOV A, @R1; GET COMPUTER MERGE PATH
	
	ANL A, #0x02; MASK
	CJNE A, #0x02, NO_COMPUTER_TOKEN
	
	;COMPUTER TOKEN FOUND AND STORED IN R1. MAIN ROUTINE CLEARS THAT REGISTER. MAKE THE COMPUTER TOKEN GO TO HOME LOCATION
	;FIND WHICH COMPUTER TOKEN HAS THIS LOCATION
	;COMPUTER TOKEN LOCATION 0x35, 0x36, 0x37, 0x38
	;CHECK WHICH LOCATION ABOVE HAS THE COMPUTER TOKEN
	MOV 0x07, R0; BACKUP R0 IN R7
	MOV R0, #0x34
	
	CHECK_NEXT_COMP_TOKEN:
	INC R0
	MOV A, @R0
	CJNE A, 0x01, CHECK_NEXT_COMP_TOKEN
	;FOUND TOKEN. STORED IN R0
	MOV @R0, #0x00; RESET TOKEN ADDRESS
	MOV 0x3B, @R1
	ANL 0x3B, #0xFD; REMOVE THE COMPUTER TOKEN
	MOV @R1, 0x3B
	
	;RESTORE POINTERS
	MOV R0, 0x07
	MOV R1, 0x3A
	
	NO_COMPUTER_TOKEN:
	SETB 0x20.1; VALID FLAG
	RET
	
	INVALID_PLAYER_LOCATION:
	;INVALID
	LCALL NA_LCD_MSG
	MOV R2, #18;INIT COUNTER
	LCALL TIMER1_WAIT
	
	CLR 0x20.1; INVALID FLAG
	RET
	

ORG 700H
	VALIDITY_CHECK:
	;THIS SUBROUTINE IS USED FOR CHECKING THE VALIDIITY OF THE DIE ROLL.
	;IF DIE ROLL VALUE CAN BE USED TO PERFORM A VALID MOVE THEN THIS SUBROUTINE
	;SETS THE FLAG 0x20.3 STATING A VALID DIE ROLL
	
	;CALL THIS SUBROUTINE WITH TOKEN ADDRESS - 1 VALUE IN R0 AND TOKEN MASK IN R6
	;USING R7 COUNTER 
	
	MOV R7, #5
	
	VALIDITY_CHECK1_CONT:
	DJNZ R7, CONT_VALIDITY_CHECK1
	;NO VALID MOVES LEFT WITH PLAYER. LET COMPUTER PLAY
	
	LCALL INVALID_LCD_MSG
	MOV R2, #18;INIT COUNTER
	LCALL TIMER1_WAIT
	
	CLR 0x20.3
	RET; RETURN FROM HERE.
	
	CONT_VALIDITY_CHECK1:
	INC R0
	MOV A, @R0
	JNZ FOUND_TOKEN_OUTSIDE_HOME
	
	;INDICATES 6 WAS SCORED, A TOKEN IS AVAILABLE AT THE HOME POSITION
	JNB 0x20.0, VALIDITY_CHECK1_CONT; SKIP THIS STEP IF '6' WAS SCORED
	
	;VALID
	SETB 0x20.3
	RET
	
	FOUND_TOKEN_OUTSIDE_HOME:
	;VALID TOKEN POSITION FOUND. NOW CHECK IF TOKENS HAVE VALID END ADDRESS
	ADD A, 0x39; ADD CURRENT DIE VAL TO VALID TOKEN
	CLR C; CLEAR CARRY
	SUBB A, #0x80
	;IF CARRY GENERATED, THEN INVALID MOVE
	JNC VALIDITY_CHECK1_CONT; GO BACK
	;CARRY SO VALID TOKEN FOUND
	
	;CHECK IF THAT LOCATION HAS SAME PLAYER TOKEN
	MOV A, @R0
	ADD A, 0x39
	MOV R1, A
	MOV A, @R1
	ANL A, 0x06; TOKEN MASK
	CJNE A, 0x06, VALID_TRUE;IF END ADDRESS DOES NOT HAVE THE RED PATTERN THIS IT IS VALID
	;INVALID
	SJMP VALIDITY_CHECK1_CONT;REPEAT CHECK WITH NEXT TOKEN
	
	VALID_TRUE:
	SETB 0x20.3
	RET

	
ORG 750H
	COMPUTER_DIE:
	;COMPUTER DIE VALUE IS RETURNED
	;0x39 HAS THE DIE VALUE
	MOV R2, #25;INIT COUNTER
	
	;PERFORM TIMER OPERATON HERE
	CLR 0x20.2
	SETB TR1
	WAIT_FOR_TIMER2: 
	LCALL QUICK_DIE
	JNB 0x20.2, WAIT_FOR_TIMER2
	CLR TR1
	
	;SHOW DIE VALUE
	MOV A, #0x85;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, TL0; DIE
	CLR C
	SUBB A, #0xF9
	MOV 0x39, A; BACKUP A DIE VALUE
	ADD A, #0x30

	
;;	;--------TEST--------
	;ALWAYS GIVE 6 DIE VALUE AFTER ROLL
;	MOV A, #0x34
;	MOV 0x39, #0x04
	
	LCALL LCD_DATA_SEND
	RET

	
ORG 800H
	PLAYER_DIE:
	;HERE THE PLAYER'S DIE VALUE IS RETURNED. 0x20.4 IS SET IF RESET BUTTON IS CLICKED
	CLR 0x20.4; CLEAR RESET INDICATOR
	;0x39 CONTAINS DIE VALUE. A HAS ASCII VALUE OF DIE
	;POLL P0.3
	WAIT_FOR_PLAYER_ROLL: 
	LCALL QUICK_DIE
	JNB P0.0, RESET_CLICKED
	JB P0.3, WAIT_FOR_PLAYER_ROLL
	
	;BUTTON CLICKED. SHOW DIE VALIE
	MOV A, #0x85;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, TL0; DIE
	CLR C
	SUBB A, #0xF9
	MOV 0x39, A; BACKUP A DIE VALUE
	ADD A, #0x30
	
	;WAIT FOR PLAYER TO RELEASE THE ROLL BUTTON
	WAIT_FOR_PLAYER_RELEASE:
	JNB P0.3, WAIT_FOR_PLAYER_RELEASE
	
;;	;--------TEST--------
;	;ALWAYS GIVE 6 DIE VALUE AFTER ROLL
;	MOV A, #0x31
;	MOV 0x39, #0x01
;;	
	LCALL LCD_DATA_SEND
	RET
	
	
	RESET_CLICKED:
	SETB 0x20.4; RESET OCCURRED
	RET
	
	
ORG 870H
	QUICK_DIE:
	;SHOW DIE ROLL ON LCD
	MOV A, #0x85;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, TL0; DIE
	LCALL LCD_DATA_SEND
	RET


ORG 0890H
	PLAYER_LCD:
	;SHOW 'PLAYER' ON LCD LINE 0xC0
	MOV A, #0xC0;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x50; P
	LCALL LCD_DATA_SEND
	MOV A, #0x4C; L
	LCALL LCD_DATA_SEND
	MOV A, #0x41; A
	LCALL LCD_DATA_SEND
	MOV A, #0x59; Y
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x52; R
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	MOV A, #0x20; SP
	LCALL LCD_DATA_SEND
	RET
	
ORG 8C0H
	COMPUTER_LCD:
	;SHOW 'MACHINE' ON LCD LINE 0xC0
	MOV A, #0xC0;CURSOR LOCATION
	LCALL LCD_CMD_SEND
	MOV A, #0x43; C
	LCALL LCD_DATA_SEND
	MOV A, #0x4F; O
	LCALL LCD_DATA_SEND
	MOV A, #0x4D; M
	LCALL LCD_DATA_SEND
	MOV A, #0x50; P
	LCALL LCD_DATA_SEND
	MOV A, #0x55; U
	LCALL LCD_DATA_SEND
	MOV A, #0x54; T
	LCALL LCD_DATA_SEND
	MOV A, #0x45; E
	LCALL LCD_DATA_SEND
	MOV A, #0x52; R
	LCALL LCD_DATA_SEND
	RET


;############## LCD Subroutines ##################
ORG 0930H
	LCD_CMD_SEND:
	;CMD TO BE SENT IS STORED IN ACC
	MOV P1, A
	CLR RS; SENDING COMMAND
	SETB EN
	CLR EN
	LCALL LCD_BUSY_CHECK
	SWAP A; SEND LOWER NIBBLE
	MOV P1, A
	CLR RS; SENDING COMMAND
	SETB EN
	CLR EN
	LCALL LCD_BUSY_CHECK
	
	RET
	
ORG 0950H
	LCD_DATA_SEND:
	;DATA TO BE SENT IS STORED IN ACC
	MOV P1, A
	SETB RS; SENDING DATA
	SETB EN
	CLR EN
	LCALL LCD_BUSY_CHECK
	SWAP A; SEND LOWER NIBBLE
	MOV P1, A
	SETB RS; SENDING DATA
	SETB EN
	CLR EN
	LCALL LCD_BUSY_CHECK
	RET
	
ORG 0970H
	
	LCD_BUSY_CHECK:
	MOV R4, #0x07
	REP:
	DJNZ R4, REP
	RET
	
ORG 0980H
	CLEAR_LCD:
	MOV A, #0x01;CLEAR DISPLAY
	LCALL LCD_CMD_SEND
	;WAIT FOR LCD TO CLEAR
	MOV R0, #0x4F; LONG DELAY
	REP2:
	LCALL LCD_BUSY_CHECK
	DJNZ R0, REP2
	
	RET
	
	
;############## 4094 SUBROUTINE ###############
ORG 09A0H
	;THE FOLLOWING SUBROUTINE IS USED FOR UPDATING THE 4094s WITH DATA IN LOCATION 0x5C TILL 0x7F
	;0x30 IS USED AS A COUNTER
	;R7 IS USED FOR STORING THE RAM DATA
	
	UPDATE_RED_RGB:
	CLR STR; CLEAR STROBE
	MOV R0, #0x5B; INIT THE DATA POINTER
	MOV A, #0; CLEAR A REGISTER
	CLR C; CLEAR CARRY
	;READ THE DATA IN THE LOCATION. IF THE DATA IS 0x01 THEN APPEND IT TO 'A' REGISTER. ELSE APPEND 0
	;TO 'A' REGISTER
	
	REPEAT_NEXT_BYTE_R:
	MOV 0x30, #9; INIT COUNTER
	CHECK_NEXT_R:
	CJNE R0, #0x7F, NOT_READ_ALL_R
	;TILL HERE ALL THE RAM LOC WAS READ.
	;ADDITIONAL 4 SHIFTS ARE REQUIRED TO BE DONE WHICH ADDS THE PLAYER TOKEN AT HOME
	
;--------------- ADD TOKEN AT HOME INFO HERE -------------
	;FOR RED: TOKEN 1: 0x31
	;		  TOKEN 2: 0x32
	;		  TOKEN 3: 0x33
	;		  TOKEN 4: 0x34	
	;IF VALUE IS 0 THEN TOKEN AT HOME
	MOV R0, #0x30
	
	REPEAT_TOKEN_HOME_R:
	
	CJNE R0, #0x34, NOT_READ_ALL_TOKEN_R
	;ALL TOKENS READ
	SJMP ENDING_R_UPDATE; END ROUTINE CALLED
	
	NOT_READ_ALL_TOKEN_R:
	INC R0
	MOV 0x07, @R0
	CJNE R7, #0x00, R_NOT_AT_HOME
	;TOKEN AT HOME
	SETB C
	RRC A
	SJMP REPEAT_TOKEN_HOME_R
	
	R_NOT_AT_HOME:
	CLR C
	RRC A
	SJMP REPEAT_TOKEN_HOME_R
;---------------------------------------------------------
	
	ENDING_R_UPDATE:
	MOV 0x30, #8
	
	KEEP_SENDING_R1:
		RRC A
		;SEND THE DATA
		CLR CLK_R
		MOV DAT,C; SET THE DATA ON THE PIN
		SETB CLK_R	
		DJNZ 0x30,KEEP_SENDING_R1
	;DONE SENDING THE DATA
	
	;DONE SENDING
	SETB STR; CLEAR STROBE
	RET
	
	
	NOT_READ_ALL_R:
	DJNZ 0x30, CHECK_NEXT0_R
	;SEND THE DATA TO 4094
	MOV 0x30, #8; INIT THE POINTER
	CLR C
	KEEP_SENDING_R:
		RRC A
		;SEND THE DATA
		CLR CLK_R
		MOV DAT,C; SET THE DATA ON THE PIN
		SETB CLK_R	
		DJNZ 0x30,KEEP_SENDING_R
	;DONE SENDING THE DATA
	MOV A, #0; CLEAR A REGISTER
	CLR C; CLEAR CARRY
	SJMP REPEAT_NEXT_BYTE_R
	
	CHECK_NEXT0_R:
	INC R0
	MOV 0x07, @R0; STORE DATA IN 0x30
	ANL 0x07, #0x01; MASK OTHER BITS
	CJNE R7, #0x01, NOT_R
	;FOUND A TOKEN
	SETB C
	RRC A; ADD THE DATA
	SJMP CHECK_NEXT_R
	
	NOT_R:
	;NOT RED TOKEN
	CLR C
	RRC A; ADD THE DATA
	SJMP CHECK_NEXT_R

;########################### FOR GREEN ##############################

	UPDATE_GREEN_RGB:
	CLR STR; CLEAR STROBE
	MOV R0, #0x5B; INIT THE DATA POINTER
	MOV A, #0; CLEAR A REGISTER
	CLR C; CLEAR CARRY
	;READ THE DATA IN THE LOCATION. IF THE DATA IS 0x01 THEN APPEND IT TO 'A' REGISTER. ELSE APPEND 0
	;TO 'A' REGISTER
	
	REPEAT_NEXT_BYTE_G:
	MOV 0x30, #9; INIT COUNTER
	CHECK_NEXT_G:
	CJNE R0, #0x7F, NOT_READ_ALL_G
	;TILL HERE ALL THE RAM LOC WAS READ.
	;ADDITIONAL 4 SHIFTS ARE REQUIRED TO BE DONE WHICH ADDS THE PLAYER TOKEN AT HOME
	
;--------------- ADD TOKEN AT HOME INFO HERE -------------
	;FOR GREEN: TOKEN 1: 0x35
	;		  	TOKEN 2: 0x36
	;		  	TOKEN 3: 0x37
	;		  	TOKEN 4: 0x38	
	;IF VALUE IS 0 THEN TOKEN AT HOME
	MOV R0, #0x34
	
	REPEAT_TOKEN_HOME_G:
	
	CJNE R0, #0x38, NOT_READ_ALL_TOKEN_G
	;ALL TOKENS READ
	SJMP ENDING_G_UPDATE; END ROUTINE CALLED
	
	NOT_READ_ALL_TOKEN_G:
	INC R0
	MOV 0x07, @R0
	CJNE R7, #0x00, G_NOT_AT_HOME
	;TOKEN AT HOME
	SETB C
	RRC A
	SJMP REPEAT_TOKEN_HOME_G
	
	G_NOT_AT_HOME:
	CLR C
	RRC A
	SJMP REPEAT_TOKEN_HOME_G
;---------------------------------------------------------
	
	ENDING_G_UPDATE:
	MOV 0x30, #8
	
	KEEP_SENDING_G1:
		RRC A
		;SEND THE DATA
		CLR CLK_G
		MOV DAT,C; SET THE DATA ON THE PIN
		SETB CLK_G	
		DJNZ 0x30,KEEP_SENDING_G1
	;DONE SENDING THE DATA
	
	;DONE SENDING
	SETB STR; CLEAR STROBE
	RET
	
	
	NOT_READ_ALL_G:
	DJNZ 0x30, CHECK_NEXT0_G
	;SEND THE DATA TO 4094
	MOV 0x30, #8; INIT THE POINTER
	CLR C
	KEEP_SENDING_G:
		RRC A
		;SEND THE DATA
		CLR CLK_G
		MOV DAT,C; SET THE DATA ON THE PIN
		SETB CLK_G	
		DJNZ 0x30,KEEP_SENDING_G
	;DONE SENDING THE DATA
	MOV A, #0; CLEAR A REGISTER
	CLR C; CLEAR CARRY
	SJMP REPEAT_NEXT_BYTE_G
	
	CHECK_NEXT0_G:
	INC R0
	MOV 0x07, @R0; STORE DATA IN 0x30
	ANL 0x07, #0x02; MASK OTHER BITS
	CJNE R7, #0x02, NOT_G
	;FOUND A TOKEN
	SETB C
	RRC A; ADD THE DATA
	SJMP CHECK_NEXT_G
	
	NOT_G:
	;NOT RED TOKEN
	CLR C
	RRC A; ADD THE DATA
	SJMP CHECK_NEXT_G
	RET
	
END